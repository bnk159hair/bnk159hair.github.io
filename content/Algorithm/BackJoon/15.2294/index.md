---
emoji: 🔮
title: 백준 2294, 동전2
date: '2023-08-26 23:51:00'
author: 하이영
tags: 알고리즘 백준
categories: 알고리즘
---

<br/>

## 문제 푸는데 필요한 정보

- n가지 종류의 동전이 있음
- 각각의 동전을 몇개라도 사용해서 합이 k원이 되도록 하고 싶음
- 이 때 동전의 개수가 최소여야 함
- 동전의 구성이 같은데, 순서만 다른 것은 같은 경우
- n은 1이상 100이하, k는 1이상 10000이하
- 동전의 가치는 100000이하의 자연수
- 가치가 같은 동전이 여러 번 주어질 수 있음

<br/>
<br/>

## 문제 푸는데 필요한 알고리즘

- 현재 동전을 만드는 방법은 주어진 동전을 하나씩 더해서 만드는 것이다.
  - 예를 들어 13원의 경우 12원을 만들 수 있는 경우에 1원을 더하거나, 8원 경우의 수에 5원을 더하는 방식으로
- 따라서 dp 테이블을 inf 값으로 초기화 시키고 1원부터 K원까지 반복하면서 주어진 동전을 더하는 경우의 수 중 가장 작은 값을 저장시킨다.

  <br/>

  <br/>
  <br/>

## 실수한 내용 및 고찰

- 알고리즘은 맞게 구성했지만 문제를 제대로 읽지 않아 불가능한 경우 처리를 하지 않았고 범위를 잘 못 이해해 index 값을 벗어나 에러가 발생하는 실수를 했다.
- 한동안 알고리즘을 못 풀다가 다시 풀면서 문제 정리를 적지 않고 바로 풀이를 시작했는데 이로 인해 문제에 대해 꼼꼼히 파악하지 못한것 같다. 항상 방심하지 않고 차분히 문제를 정리하고 풀이에 임해야겠다.

<br/>
<br/>

## 코드

```python
import sys
input = sys.stdin.readline


N, K = map(int, input().split())
coin = [int(input()) for _ in range(N)]
dp = [float("inf") for _ in range(100001)]
coin = set(coin)  # 중복 제거
coin = list(coin)
coin.sort()  # 순서대로 확인할거여서 정렬
for i in coin:
    dp[i] = 1  # 하나로만 만들수 있는 경우
for i in range(1, K+1):
    for j in coin:
        if i-j <= 0:  # 더해볼 동전이 없을 경우
            break
        dp[i] = min(dp[i], dp[i-j]+1)
if dp[K] == float("inf"):
    print(-1)
else:
    print(dp[K])


```

```toc

```
