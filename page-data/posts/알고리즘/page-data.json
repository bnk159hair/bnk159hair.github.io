{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/알고리즘",
    "result": {"pageContext":{"currentCategory":"알고리즘","categories":["All","알고리즘","개발공부","featured","Ubuntu","자격증","개발정보","블로그"],"edges":[{"node":{"id":"1dc55a45-27d4-564e-ba31-05d0ec444c7c","excerpt":"문제 푸는데 필요한 정보 땅의 크기는 N x N, r행 c열에는 A[r][c]만큼의 인구가 존재 인접한 나라 사이에는 국경선이 존재 인구 이동은 하루 동안 진행 되며 인구 차이가 L 이상 R 이하인 국가 끼리는 국경선이 열림 - 연합 연합을 이루는 국가의 인구수는 (인구수 총합 / 국가의 수)가 된다. 소수점은 버림 문제 푸는데 필요한 알고리즘 dfs를 통해 해결할 수 있는 문제이다. 특정 방향 국가와는 연합이 가능하고 다른 방향 국가와는 연합이 불가능 할 수 있기에 전체 땅에서 연합은 1개 이상 존재할 수도있음 따라서 방문하지 않은 모든 노드에 대해 dfs를 수행한다. 인구 이동은 연합이 생기지 않을 때까지 반복되므로\r\nchanged 변수를 통해 인구 이동이 발생했는지를 확인한다. dfs를 수행할 때는 4방 탐색을 통해 진행 되며 연합이 생기는 나라의 인구 합도 같이 구한다. 연합이 생기는 경우에 chaged를 true로 설정한다. 또한 연합(4방 탐색을 통해 방문한 노드)를 기…","fields":{"slug":"/Algorithm/BackJoon/05.16234/"},"frontmatter":{"categories":"알고리즘","title":"백준 16234, 인구 이동","date":"August 07, 2023"}},"next":{"fields":{"slug":"/Algorithm/BackJoon/04.1153/"}},"previous":null},{"node":{"id":"4a7a91ca-cc0e-5495-8a8a-a979387d3cf2","excerpt":"문제 푸는데 필요한 정보 임의의 자연수가 주어졌을 때 네 개의 소수의 합으로 분해해야 한다. 자연수의 범위가 1부터 1,000,000(백만)이다. 출력이 불가능한 경우는 -1을 출력한다. 문제 푸는데 필요한 알고리즘 백트래킹으로 접근해보았다. 분해해야하는 개수는 4개로 고정, 각각의 수는 모두 소수여야 하므로 주어지는 자연수 N이하의 모든 소수를 구해 배열을 구한다. 이 때 소수는 에라토스테네스의 체를 이용해 구한다. 길이가 4이고 합이 N일 때 문자열을 출력하고 종료하는 재귀함수를 작성한다. 배열의 모든 값에 대해 경우의 수를 찾는다. 찾는 중 길이가 4를 넘거나 합이 이미 N을 넘는 경우는 더 이상 찾을 필요가 없기에 이 때는 함수를 종료시킨다. 소수의 가장 작은 값부터 합을 더하기 시작하면 무조건 길이가 4가 될때까지 합 연산을 진행하게 되므로, 소수의 가장 큰 값부터 합을 더하기 시작해서 불필요한 연산들을 제거한다. (실수했던 부분)\r\n 실수한 내용 및 고찰 문제 자체는 어…","fields":{"slug":"/Algorithm/BackJoon/04.1153/"},"frontmatter":{"categories":"알고리즘","title":"백준 1153, 네 개의 소수","date":"August 06, 2023"}},"next":{"fields":{"slug":"/Development/SSAFY/openvidu-series/openvidu-deployment-test/"}},"previous":{"fields":{"slug":"/Algorithm/BackJoon/05.16234/"}}},{"node":{"id":"f1b7ec26-111a-5c28-9728-05468eec2736","excerpt":"문제 푸는데 필요한 정보 전파의 기본 단위는 { 0 , 1 } 두 가지로 구성되어있으며, x+ ( ) 는 임의의 개수(최소 1개) x의 반복으로 이루어진 전파의 집합을 나타낸다. 반복을 의미하는 + 외에도 or 를 의미하는 | 기호가 있다. { x | y } 는 x 혹은 y 를 의미하는 것으로, { 0+ | 1+ } 는 { 0 , 1 , 00 , 11 , 000 , 111 , … } 의 집합을 의미한다. 정리하면 뒤에 ’+‘가 붙은 숫자는 최소 1번이상 반복되어야하며, 괄호 뒤에 붙은 경우는 해당 괄호가 1회 이상 반복되는 것이다. 문제에 있는 예시는 경우의 수가 순서대로 나오는 것이 아니여서 이해하는데 어려움이 있었다. 문제 푸는데 필요한 알고리즘 백트래킹으로 접근해보았다. 문제에서 제공하는 패턴인 (100+1+ | 01)+ 의 경우 우선 괄호안을 볼 때 100으로 시작하거나 100으로 시작하면 0이 반복 되어야 하고 0이 아닌 1이 나오게 되면 다음 0과 1에 따라 경우의 수가…","fields":{"slug":"/Algorithm/BackJoon/03.1013/"},"frontmatter":{"categories":"알고리즘","title":"백준 1013, Contact","date":"August 05, 2023"}},"next":{"fields":{"slug":"/Development/Linux/java-jdk-management/"}},"previous":{"fields":{"slug":"/Development/SSAFY/openvidu-series/openvidu-deployment-test/"}}},{"node":{"id":"29b44aba-bc46-55d1-bd89-1d49515bfbb9","excerpt":"문제 푸는데 필요한 정보 LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다. 예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다. 문제 푸는데 필요한 알고리즘 점화식을 세움으로써 해결할 수 있기에 해당 문제는 DP로 접근해야 한다. DP 테이블은 첫번째 (문자열의 길이+1) X (두번째 문자열의 길이+1) 크기의 2차원 배열이어야 한다. DP 테이블의 현재 값[x][y]이 정해지는 경우의 수는 총 2개이다. 두 문자열의 각각 위치[x][y]의 문자값이 같은 경우 이 두 문자는 아직 비교가 안되어야하기에 각 문자열의 -1 위치[x-1][y-1]에 대한 테이블 값에 +1을 한다. 같지 않은 경우 현재 문자가 다른 문자열의 이전 문자값([x-1][y] or [x][y-1])과 비교된 값 2개중 큰 값으로 정한다. 예를 들어 문자열이 ABCD와 ACBD…","fields":{"slug":"/Algorithm/BackJoon/02.9251/"},"frontmatter":{"categories":"알고리즘","title":"백준 9251, LCS","date":"July 27, 2023"}},"next":{"fields":{"slug":"/certificate/Engineer-Information_Processing/Practice-03/"}},"previous":{"fields":{"slug":"/Development/SSAFY/chrome-(ERR_SSL_PROTOCOL_ERROR)/"}}},{"node":{"id":"0575b4f0-aabd-53d1-b4c2-77cb0ff24cb6","excerpt":"문제 푸는데 필요한 정보 N X M 행렬로 표현되는 맵이 주어짐 0은 이동할 수 있는 곳, 1은 이동할 수 없는 곳 (1, 1)에서 (N, M)의 위치까지 최단 경로로 이동해야함 최단 경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말함 이 때 시작하는 칸과 끝나는 칸도 포함해서 세야함 이동 도중 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 한 개까지 부수고 이동해도 됌 한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸 문제 푸는데 필요한 알고리즘 전체적인 풀이법은 BFS를 통한 최단 경로를 구해내는 것과 유사하다. 하지만 이동 도중 벽을 한번 부술 수 있다는 것이 차이점 방문 처리의 경우에도 단순한 2차원 배열로는 불가능하다 한 지역이라도 벽을 부수고 온 경우와 벽을 부수지 않고 온 경우가 존재하기 때문 따라서 3차원 배열로 구현 ( 1일 때는 아직 부수지 않음, 0일 때는 이미 부수고 옴) 현재 위치에서 이동할 수 있는 경우의 수는 총 3가지이다. 벽을 부수지 …","fields":{"slug":"/Algorithm/BackJoon/01.2206/"},"frontmatter":{"categories":"알고리즘","title":"백준 2206, 벽 부수고 이동하기","date":"July 15, 2023"}},"next":{"fields":{"slug":"/gatsby-github-blog/"}},"previous":{"fields":{"slug":"/certificate/Engineer-Information_Processing/Practice-01/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}