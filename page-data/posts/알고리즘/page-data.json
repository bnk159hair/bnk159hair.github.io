{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/알고리즘",
    "result": {"pageContext":{"currentCategory":"알고리즘","categories":["All","알고리즘","Ubuntu","개발공부","자격증","개발정보","블로그","featured"],"edges":[{"node":{"id":"f1b7ec26-111a-5c28-9728-05468eec2736","excerpt":"백준 1013, Contact 문제 푸는데 필요한 정보 전파의 기본 단위는 { 0 , 1 } 두 가지로 구성되어있으며, x+ ( ) 는 임의의 개수(최소 1개) x의 반복으로 이루어진 전파의 집합을 나타낸다. 반복을 의미하는 + 외에도 or 를 의미하는 | 기호가 있다. { x | y } 는 x 혹은 y 를 의미하는 것으로, { 0+ | 1+ } 는 { 0 , 1 , 00 , 11 , 000 , 111 , … } 의 집합을 의미한다. 정리하면 뒤에 ’+‘가 붙은 숫자는 최소 1번이상 반복되어야하며, 괄호 뒤에 붙은 경우는 해당 괄호가 1회 이상 반복되는 것이다. 문제에 있는 예시는 경우의 수가 순서대로 나오는 것이 아니여서 이해하는데 어려움이 있었다. 문제 푸는데 필요한 알고리즘 백트래킹으로 접근해보았다. 문제에서 제공하는 패턴인 (100+1+ | 01)+ 의 경우 우선 괄호안을 볼 때 100으로 시작하거나 100으로 시작하면 0이 반복 되어야 하고 0이 아닌 1이 나오게 되면 다…","fields":{"slug":"/Algorithm/BackJoon/03.1013/"},"frontmatter":{"categories":"알고리즘","title":"백준 1013, Contact","date":"August 05, 2023"}},"next":{"fields":{"slug":"/Development/Linux/java-jdk-management/"}},"previous":null},{"node":{"id":"29b44aba-bc46-55d1-bd89-1d49515bfbb9","excerpt":"백준 9251, LCS 문제 푸는데 필요한 정보 LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다. 예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다. 문제 푸는데 필요한 알고리즘 점화식을 세움으로써 해결할 수 있기에 해당 문제는 DP로 접근해야 한다. DP 테이블은 첫번째 (문자열의 길이+1) X (두번째 문자열의 길이+1) 크기의 2차원 배열이어야 한다. DP 테이블의 현재 값[x][y]이 정해지는 경우의 수는 총 2개이다. 두 문자열의 각각 위치[x][y]의 문자값이 같은 경우 이 두 문자는 아직 비교가 안되어야하기에 각 문자열의 -1 위치[x-1][y-1]에 대한 테이블 값에 +1을 한다. 같지 않은 경우 현재 문자가 다른 문자열의 이전 문자값([x-1][y] or [x][y-1])과 비교된 값 2개중 큰 값으로 정한다. 예를 들어 문자…","fields":{"slug":"/Algorithm/BackJoon/02.9251/"},"frontmatter":{"categories":"알고리즘","title":"백준 9251, LCS","date":"July 27, 2023"}},"next":{"fields":{"slug":"/certificate/Engineer-Information_Processing/Practice-03/"}},"previous":{"fields":{"slug":"/Development/SSAFY/chrome-(ERR_SSL_PROTOCOL_ERROR)/"}}},{"node":{"id":"0575b4f0-aabd-53d1-b4c2-77cb0ff24cb6","excerpt":"백준 2206, 벽 부수고 이동하기 문제 푸는데 필요한 정보 N X M 행렬로 표현되는 맵이 주어짐 0은 이동할 수 있는 곳, 1은 이동할 수 없는 곳 (1, 1)에서 (N, M)의 위치까지 최단 경로로 이동해야함 최단 경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말함 이 때 시작하는 칸과 끝나는 칸도 포함해서 세야함 이동 도중 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 한 개까지 부수고 이동해도 됌 한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸 문제 푸는데 필요한 알고리즘 전체적인 풀이법은 BFS를 통한 최단 경로를 구해내는 것과 유사하다. 하지만 이동 도중 벽을 한번 부술 수 있다는 것이 차이점 방문 처리의 경우에도 단순한 2차원 배열로는 불가능하다 한 지역이라도 벽을 부수고 온 경우와 벽을 부수지 않고 온 경우가 존재하기 때문 따라서 3차원 배열로 구현 ( 1일 때는 아직 부수지 않음, 0일 때는 이미 부수고 옴) 현재 위치에서 이동할 수 있는 경우의…","fields":{"slug":"/Algorithm/BackJoon/01.2206/"},"frontmatter":{"categories":"알고리즘","title":"백준 2206, 벽 부수고 이동하기","date":"July 15, 2023"}},"next":{"fields":{"slug":"/gatsby-github-blog/"}},"previous":{"fields":{"slug":"/certificate/Engineer-Information_Processing/Practice-01/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}